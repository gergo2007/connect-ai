/**
 * Copyright (c) 2022, Salesforce, Inc.,
 * All rights reserved.
 * For full license text, see the LICENSE.txt file
 */

function e(e){this.message=e;}e.prototype=new Error,e.prototype.name="InvalidCharacterError";var r="undefined"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,"");if(t.length%4==1)throw new e("'atob' failed: The string to be decoded is not correctly encoded.");for(var n,o,a=0,i=0,c="";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o);return c};function t(e){var t=e.replace(/-/g,"+").replace(/_/g,"/");switch(t.length%4){case 0:break;case 2:t+="==";break;case 3:t+="=";break;default:throw "Illegal base64url string!"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t="0"+t),"%"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e;}function o(e,r){if("string"!=typeof e)throw new n("Invalid token specified");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(".")[o]))}catch(e){throw new n("Invalid token specified: "+e.message)}}n.prototype=new Error,n.prototype.name="InvalidTokenError";

/**
 * Copyright (c) 2022, Salesforce, Inc.,
 * All rights reserved.
 * For full license text, see the LICENSE.txt file
 */

const LogLevelMap = {
    TRACE: 4,
    DEBUG: 3,
    INFO: 2,
    WARN: 1,
    ERROR: 0,
};
/**
 * A simple Logger implementation.
 */
class ConsoleLogger {
    constructor(level = 'WARN', 
    // eslint-disable-next-line no-console
    printer = console.log, formatter = (level, message) => `${level}: ${message}`) {
        this.level = level;
        this.printer = printer;
        this.formatter = formatter;
        this.messages = [];
    }
    trace(message) {
        this.log('TRACE', message);
    }
    debug(message) {
        this.log('DEBUG', message);
    }
    info(message) {
        this.log('INFO', message);
    }
    warn(message) {
        this.log('WARN', message);
    }
    error(message) {
        this.log('ERROR', message);
    }
    log(level, message) {
        if (LogLevelMap[level] > LogLevelMap[this.level]) {
            return;
        }
        this.printer(this.formatter(level, message));
    }
}
/**
 * Constructs a new LoggerService.
 */
function loggerService(level, printer, formatter) {
    return new ConsoleLogger(level, printer, formatter);
}

var HttpStatusCode;
(function (HttpStatusCode) {
    HttpStatusCode[HttpStatusCode["Ok"] = 200] = "Ok";
    HttpStatusCode[HttpStatusCode["Created"] = 201] = "Created";
    HttpStatusCode[HttpStatusCode["NoContent"] = 204] = "NoContent";
    HttpStatusCode[HttpStatusCode["NotModified"] = 304] = "NotModified";
    HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
    HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
    HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
    HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
    HttpStatusCode[HttpStatusCode["ServerError"] = 500] = "ServerError";
    HttpStatusCode[HttpStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpStatusCode || (HttpStatusCode = {}));

/**
 * Represents a JWT token with its decoded info and optional extra info.
 *
 * @typeparam T - Type of the additional payload in the JWT.
 * @typeparam ExtraInfo - Type of the additional information.
 */
class JwtToken {
    /**
     * Create a new JwtToken.
     *
     * @param _token - The JWT string.
     * @param _decodedInfo - The decoded information from the JWT.
     * @param _extraInfo - Any additional information associated with the JWT.
     */
    constructor(_token, _decodedInfo, _extraInfo) {
        this._token = _token;
        this._decodedInfo = _decodedInfo;
        this._extraInfo = _extraInfo;
    }
    /**
     * Get the JWT string.
     *
     * @returns The JWT string.
     */
    get token() {
        return this._token;
    }
    /**
     * Get the additional information associated with the JWT.
     *
     * @returns The additional information.
     */
    get extraInfo() {
        return this._extraInfo;
    }
    /**
     * Get the decoded information from the JWT.
     *
     * @returns The decoded information.
     */
    get decodedInfo() {
        return this._decodedInfo;
    }
    /**
     * Get the remaining time in seconds until the JWT expires.
     *
     * @returns The remaining time in seconds.
     */
    get tokenRemainingSeconds() {
        return this.decodedInfo.exp - Date.now() / 1000;
    }
    /**
     * Check if the JWT is expired.
     *
     * @returns True if the JWT is expired, false otherwise.
     */
    get isExpired() {
        return this.tokenRemainingSeconds <= 0;
    }
}

/**
 * Default logger if none is provided. Is overwritten in non-production environments.
 */
let defaultLogger = {
    trace: () => { },
    debug: () => { },
    info: () => { },
    warn: () => { },
    error: () => { },
};
if (process.env.NODE_ENV !== 'production') {
    defaultLogger = loggerService();
}
/**
 * Decodes JWT token information and provides a default expiry if none is present.
 *
 * @param token - JWT token as a string.
 * @param defaultTokenTTLInSeconds - Default expiry time in seconds if "exp" claim is not present in token.
 * @param logger - Logger for logging warnings and errors.
 *
 * @returns An object of decoded JWT token information.
 */
function computeDecodedInfo(token, defaultTokenTTLInSeconds, logger) {
    const decodedInfo = o(token);
    if (decodedInfo.exp === undefined) {
        logger.warn(`"exp" claim is not present in the provided token.`);
        decodedInfo.exp = Date.now() / 1000 + defaultTokenTTLInSeconds;
    }
    return decodedInfo;
}
/**
 * A repository for JWT tokens.
 */
class JwtRepository {
    /**
     * @param limitInSeconds - Time in seconds before the token's expiry to notify observers.
     * @param defaultTokenTTLInSeconds - Default token expiry time in seconds if "exp" claim is not present in token.
     * @param logger - Logger for logging warnings and errors.
     */
    constructor(limitInSeconds = 5, defaultTokenTTLInSeconds = 120, logger = defaultLogger) {
        this.limitInSeconds = limitInSeconds;
        this.defaultTokenTTLInSeconds = defaultTokenTTLInSeconds;
        this.logger = logger;
        this.observers = [];
    }
    /**
     * Get the current token.
     */
    get token() {
        return this._token;
    }
    /**
     * Set the current token.
     *
     * @param token - JWT token as a string.
     * @param extraInfo - Optional extra information.
     */
    setToken(token, extraInfo) {
        const decodedInfo = computeDecodedInfo(token, this.defaultTokenTTLInSeconds, this.logger);
        this._token = new JwtToken(token, decodedInfo, extraInfo);
        this.observeTokenExpiration();
        return this._token;
    }
    /**
     * Remove the current token.
     */
    removeToken() {
        this._token = undefined;
        this.clearTimeoutHandler();
    }
    /**
     * Subscribe to the token nearing its expiration.
     *
     * @param cb - Callback function to execute when token is nearing expiration.
     */
    subscribeToTokenNearExpiration(cb) {
        this.observers.push(cb);
        this.observeTokenExpiration();
        return () => {
            this.observers = this.observers.filter((observer) => observer !== cb);
        };
    }
    /**
     * Clear the timeout handler.
     */
    clearTimeoutHandler() {
        if (this.timeoutHandler !== undefined) {
            clearTimeout(this.timeoutHandler);
        }
    }
    /**
     * Observe and handle token expiration.
     */
    observeTokenExpiration() {
        this.clearTimeoutHandler();
        if (this.observers.length === 0 || this.token === undefined) {
            return;
        }
        this.timeoutHandler = setTimeout(() => this.notifyTokenIsExpiring(), this.computeTimeoutTimeInMs());
    }
    /**
     * Compute the timeout time in milliseconds.
     */
    computeTimeoutTimeInMs() {
        const remainingSeconds = this.token.tokenRemainingSeconds;
        let timeoutTimeInSeconds = remainingSeconds - this.limitInSeconds;
        return timeoutTimeInSeconds < 0 ? 0 : timeoutTimeInSeconds * 1000;
    }
    /**
     * Notify all observers that the token is expiring.
     */
    notifyTokenIsExpiring() {
        this.observers.forEach((cb) => {
            try {
                cb.call(undefined, this.token);
            }
            catch (e) {
                this.logger.error(e.message);
            }
        });
    }
}

/**
 * JwtManager class.
 * It provides methods for managing JWT (Json Web Token), such as retrieving and refreshing.
 *
 * @template T The data type the JwtToken carries. Default to unknown.
 * @template ExtraInfo The type of the optional extra information returned by the getJwt method. Defaults to undefined.
 * @property {JwtRepository<T, ExtraInfo>} jwtRepository JwtRepository instance used for token management.
 * @property {JwtResolver<ExtraInfo>} resolver JwtResolver instance used for token retrieval.
 */
class JwtManager {
    /**
     * Constructor for JwtManager class.
     *
     * @param {JwtRepository<T, ExtraInfo>} jwtRepository JwtRepository instance used for token management.
     * @param {JwtResolver<ExtraInfo>} resolver JwtResolver instance used for token retrieval.
     * @param {JwtManagerOptions} options JwtManagerOptions bag to customize behavior.
     */
    constructor(jwtRepository, resolver, options) {
        this.jwtRepository = jwtRepository;
        this.resolver = resolver;
        if (options === null || options === void 0 ? void 0 : options.keepTokenUpdated) {
            jwtRepository.subscribeToTokenNearExpiration(() => this.refreshToken());
        }
    }
    /**
     * Method to get a JWT token.
     * If there's a token request in progress, it will return the Promise of this request.
     * If the current token is undefined or expired, it will initiate a token refresh.
     * Otherwise, it will return the current token.
     *
     * @returns {JwtToken<T, ExtraInfo> | Promise<JwtToken<T, ExtraInfo>>} The current token or the Promise of a token request.
     */
    getJwt() {
        if (this.inflightPromise) {
            return this.inflightPromise;
        }
        const token = this.jwtRepository.token;
        if (token === undefined || token.isExpired) {
            return this.refreshToken();
        }
        return token;
    }
    /**
     * Method to refresh a JWT token.
     * If a refresh request is already in progress, it will return the Promise of this request.
     * Otherwise, it will start a new refresh request and return its Promise.
     *
     * @returns {Promise<JwtToken<T, ExtraInfo>>} Promise of the refreshed token.
     */
    refreshToken() {
        if (this.inflightPromise === undefined) {
            this.inflightPromise = new Promise((resolve, reject) => {
                this.resolver
                    .getJwt()
                    .then(({ jwt, extraInfo }) => {
                    this.inflightPromise = undefined;
                    const token = this.jwtRepository.setToken(jwt, extraInfo);
                    resolve(token);
                })
                    .catch((reason) => {
                    this.inflightPromise = undefined;
                    reject(reason);
                });
            });
        }
        return this.inflightPromise;
    }
    /**
     * Method to check if a token refresh is in progress.
     *
     * @returns {boolean} true if a token refresh is in progress, false otherwise.
     */
    get isRefreshingToken() {
        return this.inflightPromise !== undefined;
    }
}

export { JwtManager, JwtRepository, JwtToken };
//# sourceMappingURL=jwt-manager.js.map
